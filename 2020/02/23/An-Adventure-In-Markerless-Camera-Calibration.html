<h1 id="an-adventure-in-markerless-camera-calibration">An adventure in markerless camera calibration</h1>
<blockquote>
  <p>It’s Febrary 1972, the A300 airliner is being unvailed in Toulouse, France.</p>
</blockquote>

<p>It’s Febrary 1972, the <a href="https://en.wikipedia.org/wiki/Airbus_A300">A300</a> airliner is being unviled in Toulouse, France. Let’s go on an adventure (In markerless camera calibration!).</p>

<p><img src="/Blog/images/2020-2-23-An-Adventure-In-Markerless-Camera-Calibration_files/A300.jpg" alt="_config.yml" /></p>

<p>Let’s keep things interesting, and pretend that we work for an aircraft manufacturer, Norton Aircraft, headquartered in Burbank, California. Let’s say we have seen this photo published in a magazine, and we want to try and learn as much about the dimensions of Airbus’s new aircraft as possible. In order to do so, we will need to mathematically reconstruct the camera used to take the photo, as well as the scene itself.</p>

<p>Now, In this case, we are lucky, because we notice the hexagonal pattern on the floor. In particular, we notice that it’s a tessellating hexagonal pattern, which can only happen if all the hexagons have identical dimensions.</p>

<p>While we don’t know the dimensions of the hexagon, we guess that each side is approximately 1.6m long, based on the high of the people in the photo. If we assume some point on the ground, say the center of a polygon is the point 0,0, we can work out the X &amp; Y location of each other polygon vertex we can see. Furthermore, we could also assume that the factory floor is flat and level. Hence the Z coordinate of each point is 0.</p>

<p>Let’s spend ±5 minutes annotating the image, using an annotation tool like label me. I’ve generated a file, which you can find attached here:</p>

<p><img src="/Blog/images/2020-2-23-An-Adventure-In-Markerless-Camera-Calibration_files/Hexagons.jpg" alt="_config.yml" /></p>

<p>Firstly, lets load in all of the x and y points:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">JSON</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">'A300.json'</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="n">polygons</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">JSON</span><span class="p">[</span><span class="s">'shapes'</span><span class="p">]:</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="s">'label'</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">polygons</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="s">'points'</span><span class="p">]</span>    
</code></pre></div></div>

<p>Ok, now doing some maths, and work out the locations of each vertex of our hexagons.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KDTree</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">polygons</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">polygons</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>    
    <span class="p">(</span><span class="n">pts_x</span><span class="p">,</span> <span class="n">pts_y</span><span class="p">)</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">poly</span><span class="p">)</span>
    
    <span class="n">pts_x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pts_x</span><span class="p">)</span>
    <span class="n">pts_y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pts_y</span><span class="p">)</span>
    
    <span class="c1">#Magic analytic formula for working out the location of each point, based on which vertex, of which polygon it is.
</span>    <span class="n">x_vertex</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y_vertex</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
    
    <span class="n">row</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">row</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="o">+</span> <span class="n">x_vertex</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">col</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">y_vertex</span>
    
    <span class="c1">#From before, we assume the sides of each polygon is 1.6m
</span>    <span class="n">x</span><span class="o">*=</span><span class="mf">1.6</span> <span class="c1">#meters
</span>    <span class="n">y</span><span class="o">*=</span><span class="mf">1.6</span> <span class="c1">#meters
</span>    
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">point</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">pts_x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">pts_y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">])</span>
        
</code></pre></div></div>

<p>Now we are presented with a minor problem, in many cases, we have annotated the same point up to 3 times, where the vertices of the hexagons meet. So let’s go and find points that are within 10 pixels, and then take their average. If we don’t do this, then we effectively over-weight some points in the image, at the expense of others.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="n">merged_indicies</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">unique_points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged_indicies</span><span class="p">:</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        
        <span class="n">indicies_to_merge</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">:</span>
                <span class="n">indicies_to_merge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> 
                <span class="n">merged_indicies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

        <span class="n">mean_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">indicies_to_merge</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">unique_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_points</span><span class="p">)</span>
        

<span class="n">unique_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">unique_points</span><span class="p">)</span>
</code></pre></div></div>

<p>So, now we have a bunch of 3D points, and corresponding 2D points in the photo.</p>

<p>Now it’s time to turn to the real magic, bundle adjustment. Basically, our task at hand, is to find a camera, which best fits the data we have measured.</p>

<p>Let’s talk more about cameras.
<em>There are many correct ways to model a camera mathematically. This is one way</em></p>

<p>Mathematically, cameras are are composed of two types of parameters, <em>Intrinsic</em> and <em>Extrinsic</em>.
The <em>Extrinsic</em> parameters define the position and rotation of the camera, with respect to the origin of the points it’s observing.</p>

<p>The <em>Intrinsic</em> parameters define the parameters of the camera itself, for example the Focal length, the location of the camera’s radial center, as well as distortion induced by the lens.</p>

<p>The <em>Extrinisic</em> parameters are comprised of 6 degrees of freedom, given our world is 3 dimensional, and there are 3 dimensions which to rotate around.</p>

<p>The <em>Intrinsic</em> parameters are more complex. There are a number of great resources, for example <em>Multiple View Computer Vision</em>, or the OpenCV documentation. However, In this case, I am assuming that the principal point, the focal length, and the radial parameters are unknown.
<em>To be clear, I’m building on the shoulders of giants, I’ve heavily adapted this example from this incredible demo by *Nikolay Mayorov</em> which you can find here: https://scipy-cookbook.readthedocs.io/items/bundle_adjustment.html*</p>

<p>Firstly, let’s go and import a bunch of stuff we will need later</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">least_squares</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">lil_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">Rot</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s">"figure.figsize"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">points_2d</span> <span class="o">=</span> <span class="n">unique_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">points_3d</span> <span class="o">=</span> <span class="n">unique_points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>


<span class="k">print</span><span class="p">(</span><span class="s">'We have {} unique points'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">points_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>We have 51 unique points
</code></pre></div></div>

<p>Let’s start by providing some “hints” to the optimiser about what the solution could be like, by putting in some reasonable starting conditions.</p>

<p>We know both the image width and height, and we can assume that the principal point is in the center of the image.</p>

<p>I think the cameras is about 10 meters off the ground.</p>

<p>To make the task of optimization easier, lets rotate the camera so that it’s facing directly down. This means that the points should be in front of/below it.</p>

<p>Let’s also start off by assuming that the camera is centered above the points. It’s obviously not correct, based on what we can see in the image, but it’s not horrifically wrong.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image_width</span> <span class="o">=</span>  <span class="mi">2251</span>
<span class="n">image_height</span> <span class="o">=</span> <span class="mi">1508</span>

<span class="n">estimated_focal_length_px</span> <span class="o">=</span> <span class="mi">2000</span>

<span class="n">camera_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s">'x'</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">as_rotvec</span><span class="p">()</span>
<span class="c1">#Rotation matrix
</span><span class="n">camera_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="c1">#C
</span><span class="n">camera_params</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_3d</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_3d</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1">#f,k1,k2,
</span><span class="n">camera_params</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">estimated_focal_length_px</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>


<span class="c1">#c_x,c_y
</span><span class="n">camera_params</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_width</span><span class="o">/</span><span class="mf">2.0</span>
<span class="n">camera_params</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_height</span><span class="o">/</span><span class="mf">2.0</span>
</code></pre></div></div>

<p>Now we come to the real magic. This function models the camera, taking points in 3D space, and converting them into points in 2D space.</p>

<p>There are lots of things going on here,</p>

<p><img src="/Blog/images/2020-2-23-An-Adventure-In-Markerless-Camera-Calibration_files/pinholeCamera.png" alt="_config.yml" /></p>

<p>Firstly, let’s talk about the camera’s intrinsic matrix.</p>

<p>Basically, it converts points from 3D space to 2D space.</p>

<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
K = 
\begin{bm…" style="color:#cc0000">\begin{equation*}
K = 
\begin{bmatrix}
f &amp; 0 &amp; c_{x} \\
0 &amp; f &amp; c_{y} \\
0 &amp; 0 &amp; 1 
\end{bmatrix}
\end{equation*}</span>

<p>We have the focal length, $f$, and the camera optical center $c_x$ and $c_y$.</p>

<p>Now let’s talk about the camera’s extrinsic matrix.</p>

<p>These are the 6 degrees of freedom that describe it’s position and orientation within the world. 
That’s 3 degrees for the position, and 3 for the orientation. At its heart, what we are doing is simple, but confusing.</p>

<p>There are so many ways to represent our setup:</p>
<ol>
  <li>Coordinate systems: 2D and 3D.
    <ul>
      <li>Left Handed or Right Handed?</li>
    </ul>
  </li>
  <li>Rotations:
    <ul>
      <li>Quaternions?</li>
      <li>Proper Euler angles (6 different ways)?</li>
      <li>Tait–Bryan angles (6 different ways)?</li>
      <li>Rodrigues rotation formula?</li>
      <li>A rotation matrix?</li>
    </ul>
  </li>
  <li>The location of the camera in to the world. (2 Different ways).</li>
</ol>

<p>Today we are going to use two different ways to represent the rotations, Firstly a <a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">Rodrigues rotation vector</a> representation, and a rotation matrix. The reason why we use two different representations is because it’s easier to optimise when we have 3 degrees of freedom, rather than a naive rotation matrix which uses 9 numbers to represent 3 degrees of freedom.</p>

<p>R represents the orientation of the camera in the World Coordinate Frame (The frame which we use to describe our 3D points).</p>

<p>In python, we can use convert from the Rodrigues rotation vector to the Rotation matrix as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">Rot</span>
<span class="n">rotation_vector</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotation_vector</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
</code></pre></div></div>

<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
R = 
\begin{bm…" style="color:#cc0000">\begin{equation*}
R = 
\begin{bmatrix}
R_1 &amp; R_2 &amp; R_3 \\
R_4 &amp; R_5 &amp; R_6 \\
R_7 &amp; R_8 &amp; R_9 
\end{bmatrix}
\end{equation*}</span>

<p>Now, let’s talk about the Project Matrix $P$ of the camera. This takes the points all the way from their location in 3D world coordinates, to pixel coordinates, assuming we have a camera without radial distortion. There are two main ways this could be formulated.</p>

<p>Firstly:
<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
P = KR[I|−C]
\…" style="color:#cc0000">\begin{equation*}
P = KR[I|−C]
\end{equation*}</span></p>

<p>Secondly:
<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
P = K[R | t]
\…" style="color:#cc0000">\begin{equation*}
P = K[R | t]
\end{equation*}</span></p>

<p>Where $t$ is:
<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
t = −RC
\end{e…" style="color:#cc0000">\begin{equation*}
t = −RC
\end{equation*}</span></p>

<p>Let’s go with the first method, where C is :</p>

<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
C = 
\begin{bm…" style="color:#cc0000">\begin{equation*}
C = 
\begin{bmatrix}
-C_X\\
-C_Y\\
-C_Z 
\end{bmatrix}
\end{equation*}</span>

<p>However, there is one subtlety alluded to before, which is the impact of radial distortion. Simply, the camera’s lens distorts the rays of light coming in, in a non-linear way.</p>

<p>We can model it using a <a href="https://en.wikipedia.org/wiki/Taylor_series">Taylor series</a>:</p>

<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
x_c = x(1 + k_…" style="color:#cc0000">\begin{equation*}
x_c = x(1 + k_1  r^2 + k_2  r^4 + k_3 r^6)
\end{equation*}</span>

<span class="katex-error" title="ParseError: KaTeX parse error: No such environment: equation* at position 7: \begin{̲e̲q̲u̲a̲t̲i̲o̲n̲*̲}̲
y_c = y(1 + k_…" style="color:#cc0000">\begin{equation*}
y_c = y(1 + k_1  r^2 + k_2 r^4 + k_3 r^6)
\end{equation*}</span>

<p>In python, we end up with:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">points_proj</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">k1</span> \<span class="n">times</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">6</span>
<span class="n">points_proj</span> <span class="o">*=</span> <span class="n">r</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">camera_params</span><span class="p">):</span>
    <span class="s">"""Convert 3-D points to 2-D by projecting onto images."""</span>
    <span class="c1">#Rotation
</span>    <span class="n">rotation_vector</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotation_vector</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
    
    <span class="c1">#Camera Center
</span>    <span class="n">C</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">IC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="o">-</span><span class="n">C</span><span class="p">])</span>
    <span class="n">RIC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">IC</span><span class="p">)</span>
    
    <span class="c1">#Make points Homogeneous
</span>    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">points</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))])</span>
    
    <span class="c1">#Perform Rotation and Translation
</span>    <span class="c1">#(n,k), (k,m) -&gt; (n,m)
</span>    <span class="n">points_proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">RIC</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    
    <span class="c1">#perspective divide 
</span>    <span class="n">points_proj</span> <span class="o">=</span> <span class="n">points_proj</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">points_proj</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    
    <span class="n">f</span>  <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    
    <span class="n">k1</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>
    <span class="n">c_x</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">c_y</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>
    
    <span class="c1">#Radial distortion
</span>    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">points_proj</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">points_proj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">points_proj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">points_proj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
    <span class="n">points_proj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">k3</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="n">y</span>
    
    <span class="c1">#Make points Homogeneous
</span>    <span class="n">points_proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">points_proj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">points_proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))])</span>
    
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c_x</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c_y</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="mf">1.0</span><span class="p">]])</span>
    
    <span class="n">points_proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points_proj</span><span class="p">,</span><span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">points_proj</span> <span class="o">=</span> <span class="n">points_proj</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">points_proj</span><span class="p">)</span>
</code></pre></div></div>

<p>This section below is really well explained by <a href="https://scipy-cookbook.readthedocs.io/items/bundle_adjustment.html">here</a>. Basically, we are optimizing to minimise a geometric error. It’s the distance between the 2D points we see, and the projection of their 3D counterparts.</p>

<p>Through a process of optimization, we aim to find parameters which result in low error, which means in turn they should represent the real parameters of the camera.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">camera_params</span><span class="p">,</span> <span class="n">points_2d</span><span class="p">,</span> <span class="n">points_3d</span><span class="p">):</span>
    <span class="c1">#Compute residuals.
</span>    <span class="n">points_proj</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">points_3d</span><span class="p">,</span> <span class="n">camera_params</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">points_proj</span> <span class="o">-</span> <span class="n">points_2d</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x0</span> <span class="o">=</span> <span class="n">camera_params</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

<span class="n">optimization_results</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span>  <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_scale</span><span class="o">=</span><span class="s">'jac'</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'lm'</span><span class="p">,</span>
                                     <span class="n">loss</span><span class="o">=</span><span class="s">'linear'</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">points_2d</span><span class="p">,</span> <span class="n">points_3d</span><span class="p">))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`ftol` termination condition is satisfied.
Function evaluations 617, initial cost 3.7406e+07, final cost 1.7290e+02, first-order optimality 5.34e+01.
</code></pre></div></div>

<p>Now let’s go and check out the results of our optimization process.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">camera_params</span> <span class="o">=</span> <span class="n">optimization_results</span><span class="o">.</span><span class="n">x</span>

<span class="n">R_Rodrigues</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">R_Rodrigues</span><span class="p">)</span>
<span class="n">R_matrix</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">Rot</span><span class="o">.</span><span class="n">from_matrix</span><span class="p">(</span><span class="n">R_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">R_Quaternion</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">as_quat</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s">'Quaternions: X: {:.3f} Y: {:.3f} Z: {:.3f} W: {:.3f} '</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">R_Quaternion</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">R_Quaternion</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">R_Quaternion</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">R_Quaternion</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Camera position relative to the origin in (M): X: {:.2f}, Y: {:.2f}, Z: {:.2f}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

<span class="n">focal_length_px</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="n">k1</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="n">k2</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
<span class="n">k3</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>

<span class="n">c_x</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="n">c_y</span> <span class="o">=</span> <span class="n">camera_params</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="s">'Focal length (Pixels): {:.2f}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">focal_length_px</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'CX, CY: {:.2f} {:.2f}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c_x</span><span class="p">,</span><span class="n">c_y</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">'K_1, K_2, K_3 : {:.6f}, {:.6f}, {:.6f}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">,</span><span class="n">k3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Mean error per point: {:.2f} pixels '</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">optimization_results</span><span class="o">.</span><span class="n">cost</span><span class="o">/</span><span class="n">points_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Quaternions: X: 0.839 Y: -0.382 Z: 0.174 W: -0.345 
Camera position relative to the origin in (M): X: -8.20, Y: -14.01, Z: 5.40
Focal length (Pixels): 1598.01
CX, CY: 1056.75 2153.95
K_1, K_2, K_3 : -0.086846, 0.195150, -0.128968
Mean error per point: 3.39 pixels 
</code></pre></div></div>

<p>Ok, first things first, the mean error per point is nearly 3.6 pixels, which is not great, not terrible. 
however It’s clear that we have found a decent solution. However there are some interesting things going on. 
In particular, the principal point lies outside the image, which is curious to say the least. One possibility is that the image was cropped.</p>

<p>Now let’s have a quick look at the errors for each point.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">optimization_results</span><span class="o">.</span><span class="n">fun</span><span class="p">),</span><span class="n">density</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Histogram of Residuals'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Absolute Residual (Pixels)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/Blog/images/2020-2-23-An-Adventure-In-Markerless-Camera-Calibration_files/output_29_0.jpg" alt="_config.yml" /></p>

<p>Ok, so the histogram looks pretty good, apart from the one point with a high residual, which is probably due to sloppy labeling/annotation.</p>

<p>Now let’s compare the points we annotated, with where they would be projected, using the camera parameters we found:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">points_2d_proj</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">points_3d</span><span class="p">,</span> <span class="n">optimization_results</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'A300.jpg'</span><span class="p">)</span>      
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">points_2d</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">points_2d</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s">'Actual'</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s">'r'</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">points_2d</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="s">'Optimised'</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s">'k'</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">'A300_points.jpg'</span><span class="p">,</span><span class="n">dpi</span> <span class="o">=</span> <span class="mi">900</span><span class="p">)</span>           

</code></pre></div></div>

<p><img src="/Blog/images/2020-2-23-An-Adventure-In-Markerless-Camera-Calibration_files/output_31_0.jpg" alt="_config.yml" /></p>

<p>Again, this looks great.
Finally, let’s overlay the hexagons on the floor, to visually build confidence in our solution.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plot_verticies</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="n">x_vertex</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y_vertex</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">row</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="o">+</span> <span class="n">x_vertex</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">col</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">y_vertex</span>

    <span class="n">x</span><span class="o">*=</span><span class="mf">1.6</span>
    <span class="n">y</span><span class="o">*=</span><span class="mf">1.6</span>

    <span class="n">points_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">7</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">points_2d_proj</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">points_3d</span><span class="p">,</span> <span class="n">optimization_results</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">)</span>
    
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">points_2d_proj</span> <span class="o">=</span> <span class="n">plot_verticies</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s">'B'</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="s">','</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">),</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s">'center'</span><span class="p">,</span><span class="n">verticalalignment</span><span class="o">=</span><span class="s">'center'</span><span class="p">)</span>
        

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">points_2d_proj</span> <span class="o">=</span> <span class="n">plot_verticies</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s">'R'</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points_2d_proj</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">+</span><span class="s">','</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">),</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s">'center'</span><span class="p">,</span><span class="n">verticalalignment</span><span class="o">=</span><span class="s">'center'</span><span class="p">)</span>


<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">'A300.jpg'</span><span class="p">,</span><span class="n">dpi</span> <span class="o">=</span> <span class="mi">900</span><span class="p">,</span><span class="n">bbox_inches</span><span class="o">=</span><span class="s">'tight'</span><span class="p">)</span>           

</code></pre></div></div>

<p><img src="/Blog/images/2020-2-23-An-Adventure-In-Markerless-Camera-Calibration_files/output_33_1.jpg" alt="_config.yml" /></p>

<p>Thanks for reading all the way to the end!</p>

<p>In the future, Let’s look more about how we can extract useful information from this image, and understand how confident we can be in our solution.</p>

<p>Thanks to <em>Nikolay Mayorov</em> who created the awesome demo of optimization in Scipy that I built upon, please find the original code <a href="https://scipy-cookbook.readthedocs.io/items/bundle_adjustment.html">here</a>.</p>

<p>Multiple View Geometry in Computer Vision is an incredible book, that I learn more from, each time I read it. in particular, for further information see:</p>
<ul>
  <li>Finite cameras. Page 153, Multiple View Geometry in Computer Vision (Second edition)</li>
  <li>Minimizing geometric error. Page 176, Multiple View Geometry in Computer Vision (Second edition)</li>
</ul>

<p>Photos by André Cros, preserved by the city archives of Toulouse and released under CC BY-SA 4.0 license.</p>
